#!/usr/bin/env ts-node
/**
 * Rate Limiting & Throttling Check Script
 * 
 * Checks for:
 * - @nestjs/throttler package presence
 * - express-rate-limit usage
 * - Throttle decorators in code
 * - Critical endpoints that need protection
 * 
 * Generates: reports/throttling_status.md
 */

import * as fs from 'fs';
import * as path from 'path';
import { Project, SourceFile, ClassDeclaration, MethodDeclaration } from 'ts-morph';

interface ThrottlingPackage {
  name: string;
  present: boolean;
  version?: string;
}

interface EndpointInfo {
  module: string;
  controller: string;
  method: string;
  httpMethod: string;
  path: string;
  hasThrottle: boolean;
  isCritical: boolean;
  criticalReason?: string;
  file: string;
  line: number;
}

interface ThrottlingUsage {
  file: string;
  type: 'decorator' | 'guard' | 'middleware' | 'config';
  location: string;
  code: string;
}

class ThrottlingCheckAuditor {
  private project: Project;
  private packagesInfo: ThrottlingPackage[] = [];
  private endpoints: EndpointInfo[] = [];
  private usage: ThrottlingUsage[] = [];
  private mainTsPath: string;

  constructor() {
    this.project = new Project({
      tsConfigFilePath: path.join(process.cwd(), 'tsconfig.json'),
      skipAddingFilesFromTsConfig: true,
    });
    this.mainTsPath = path.join(process.cwd(), 'src', 'main.ts');
  }

  async audit(): Promise<void> {
    console.log('üîç Starting Rate Limiting/Throttling Check...\n');

    // 1. Check package.json
    this.checkPackages();

    // 2. Check main.ts for global rate limiting
    this.checkMainTs();

    // 3. Scan all controllers
    this.scanControllers();

    // 4. Check for throttling usage in code
    this.checkThrottlingUsage();

    console.log(`\n‚úÖ Analysis complete!\n`);

    // 5. Generate report
    this.generateReport();

    console.log('‚ú® Audit complete!\n');
  }

  /**
   * Check packages in package.json
   */
  private checkPackages(): void {
    console.log('üì¶ Checking packages...');
    
    const packageJsonPath = path.join(process.cwd(), 'package.json');
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
    
    const allDeps = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies,
    };

    // Check for throttling packages
    const throttlingPackages = [
      '@nestjs/throttler',
      'express-rate-limit',
      'rate-limiter-flexible',
      'bottleneck',
    ];

    for (const pkg of throttlingPackages) {
      this.packagesInfo.push({
        name: pkg,
        present: !!allDeps[pkg],
        version: allDeps[pkg],
      });
    }

    const presentPackages = this.packagesInfo.filter(p => p.present);
    console.log(`  ‚úì Found ${presentPackages.length} rate limiting packages`);
    presentPackages.forEach(p => {
      console.log(`    - ${p.name}@${p.version}`);
    });
    console.log();
  }

  /**
   * Check main.ts for global rate limiting
   */
  private checkMainTs(): void {
    console.log('üîç Checking main.ts for global rate limiting...');

    if (!fs.existsSync(this.mainTsPath)) {
      console.log('  ‚ö†Ô∏è  main.ts not found');
      return;
    }

    const content = fs.readFileSync(this.mainTsPath, 'utf-8');

    // Check for express-rate-limit
    if (content.includes('rateLimit') || content.includes('express-rate-limit')) {
      const lines = content.split('\n');
      let startLine = -1;
      let endLine = -1;

      for (let i = 0; i < lines.length; i++) {
        if (lines[i].includes('rateLimit') && startLine === -1) {
          startLine = i;
        }
        if (startLine !== -1 && lines[i].includes('});') && endLine === -1) {
          endLine = i;
          break;
        }
      }

      if (startLine !== -1) {
        const rateLimitCode = lines.slice(startLine, endLine + 1).join('\n');
        
        this.usage.push({
          file: 'src/main.ts',
          type: 'middleware',
          location: `Line ${startLine + 1}-${endLine + 1}`,
          code: rateLimitCode.substring(0, 200) + (rateLimitCode.length > 200 ? '...' : ''),
        });

        console.log(`  ‚úì Found global rate limiting at lines ${startLine + 1}-${endLine + 1}`);
        
        // Extract configuration
        const windowMatch = content.match(/windowMs:\s*(\d+)/);
        const maxMatch = content.match(/max:\s*(\d+)/);
        
        if (windowMatch && maxMatch) {
          const windowMs = parseInt(windowMatch[1]);
          const max = parseInt(maxMatch[1]);
          console.log(`    Window: ${windowMs}ms, Max: ${max} requests`);
        }
      }
    } else {
      console.log('  ‚ö†Ô∏è  No global rate limiting found in main.ts');
    }
    console.log();
  }

  /**
   * Scan all controllers for endpoints
   */
  private scanControllers(): void {
    console.log('üîç Scanning controllers...');
    
    const controllersPath = path.join(process.cwd(), 'src', 'modules');
    const controllerFiles = this.findControllerFiles(controllersPath);
    
    console.log(`  Found ${controllerFiles.length} controller files\n`);

    for (const filePath of controllerFiles) {
      this.processControllerFile(filePath);
    }

    console.log(`  ‚úì Analyzed ${this.endpoints.length} endpoints`);
  }

  /**
   * Recursively find controller files
   */
  private findControllerFiles(dir: string): string[] {
    const files: string[] = [];

    if (!fs.existsSync(dir)) {
      return files;
    }

    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        files.push(...this.findControllerFiles(fullPath));
      } else if (entry.isFile() && entry.name.endsWith('.controller.ts')) {
        files.push(fullPath);
      }
    }

    return files;
  }

  /**
   * Process a single controller file
   */
  private processControllerFile(filePath: string): void {
    const sourceFile = this.project.addSourceFileAtPath(filePath);
    const relativePath = path.relative(process.cwd(), filePath);
    const moduleName = this.extractModuleName(filePath);

    const classes = sourceFile.getClasses();

    for (const classDecl of classes) {
      const controllerDecorator = classDecl.getDecorator('Controller');
      
      if (!controllerDecorator) {
        continue;
      }

      const controllerName = classDecl.getName() || 'UnnamedController';
      const controllerPath = this.extractDecoratorPath(controllerDecorator);

      // Check for class-level Throttle decorator
      const classHasThrottle = !!classDecl.getDecorator('Throttle');

      const methods = classDecl.getMethods();

      for (const method of methods) {
        const endpointInfo = this.processEndpointMethod(
          method,
          moduleName,
          controllerName,
          controllerPath,
          relativePath,
          classHasThrottle,
        );

        if (endpointInfo) {
          this.endpoints.push(endpointInfo);
        }
      }
    }

    this.project.removeSourceFile(sourceFile);
  }

  /**
   * Process endpoint method
   */
  private processEndpointMethod(
    method: MethodDeclaration,
    moduleName: string,
    controllerName: string,
    controllerPath: string,
    filePath: string,
    classHasThrottle: boolean,
  ): EndpointInfo | null {
    const httpMethods = ['Get', 'Post', 'Put', 'Patch', 'Delete'];
    let httpMethod = '';
    let routePath = '';

    for (const methodName of httpMethods) {
      const decorator = method.getDecorator(methodName);
      if (decorator) {
        httpMethod = methodName.toUpperCase();
        routePath = this.extractDecoratorPath(decorator);
        break;
      }
    }

    if (!httpMethod) {
      return null;
    }

    const fullPath = this.constructFullPath(controllerPath, routePath);
    const methodHasThrottle = !!method.getDecorator('Throttle');
    const hasThrottle = classHasThrottle || methodHasThrottle;

    // Determine if endpoint is critical
    const { isCritical, reason } = this.isEndpointCritical(
      fullPath,
      httpMethod,
      method.getName() || '',
    );

    return {
      module: moduleName,
      controller: controllerName,
      method: method.getName() || 'unknown',
      httpMethod,
      path: fullPath,
      hasThrottle,
      isCritical,
      criticalReason: reason,
      file: filePath,
      line: method.getStartLineNumber(),
    };
  }

  /**
   * Determine if endpoint is critical and needs throttling
   */
  private isEndpointCritical(
    path: string,
    httpMethod: string,
    methodName: string,
  ): { isCritical: boolean; reason?: string } {
    const pathLower = path.toLowerCase();
    const methodLower = methodName.toLowerCase();

    // Authentication endpoints
    if (
      pathLower.includes('/auth/') ||
      pathLower.includes('/login') ||
      pathLower.includes('/register') ||
      pathLower.includes('/signup')
    ) {
      return { isCritical: true, reason: 'Authentication endpoint - vulnerable to brute force' };
    }

    // Password/OTP endpoints
    if (
      pathLower.includes('password') ||
      pathLower.includes('otp') ||
      pathLower.includes('verify') ||
      pathLower.includes('confirm')
    ) {
      return { isCritical: true, reason: 'Security-sensitive endpoint' };
    }

    // Payment endpoints
    if (
      pathLower.includes('/payment') ||
      pathLower.includes('/wallet/topup') ||
      pathLower.includes('/wallet/transfer') ||
      pathLower.includes('/order') && httpMethod === 'POST'
    ) {
      return { isCritical: true, reason: 'Financial transaction endpoint' };
    }

    // File upload
    if (
      methodLower.includes('upload') ||
      pathLower.includes('/upload')
    ) {
      return { isCritical: true, reason: 'File upload - resource intensive' };
    }

    // Search/Query endpoints
    if (
      methodLower.includes('search') ||
      methodLower.includes('query') ||
      pathLower.includes('/search')
    ) {
      return { isCritical: true, reason: 'Search endpoint - resource intensive' };
    }

    // Bulk operations
    if (
      methodLower.includes('bulk') ||
      methodLower.includes('batch') ||
      pathLower.includes('/bulk')
    ) {
      return { isCritical: true, reason: 'Bulk operation - resource intensive' };
    }

    // Email/SMS sending
    if (
      methodLower.includes('send') ||
      methodLower.includes('notify') ||
      pathLower.includes('/notification')
    ) {
      return { isCritical: true, reason: 'Notification endpoint - can be abused' };
    }

    // Report generation
    if (
      methodLower.includes('report') ||
      methodLower.includes('export') ||
      pathLower.includes('/report')
    ) {
      return { isCritical: true, reason: 'Report generation - resource intensive' };
    }

    return { isCritical: false };
  }

  /**
   * Check for throttling usage in codebase
   */
  private checkThrottlingUsage(): void {
    console.log('\nüîç Checking for throttling decorators...');

    const srcPath = path.join(process.cwd(), 'src');
    this.searchThrottlingInDirectory(srcPath);

    console.log(`  Found ${this.usage.filter(u => u.type === 'decorator').length} @Throttle decorator usages`);
  }

  /**
   * Recursively search for throttling usage
   */
  private searchThrottlingInDirectory(dir: string): void {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        this.searchThrottlingInDirectory(fullPath);
      } else if (entry.isFile() && entry.name.endsWith('.ts')) {
        const content = fs.readFileSync(fullPath, 'utf-8');
        const relativePath = path.relative(process.cwd(), fullPath);

        // Check for @Throttle decorator
        if (content.includes('@Throttle')) {
          const lines = content.split('\n');
          for (let i = 0; i < lines.length; i++) {
            if (lines[i].includes('@Throttle')) {
              this.usage.push({
                file: relativePath,
                type: 'decorator',
                location: `Line ${i + 1}`,
                code: lines[i].trim(),
              });
            }
          }
        }

        // Check for ThrottlerGuard
        if (content.includes('ThrottlerGuard')) {
          const lines = content.split('\n');
          for (let i = 0; i < lines.length; i++) {
            if (lines[i].includes('ThrottlerGuard')) {
              this.usage.push({
                file: relativePath,
                type: 'guard',
                location: `Line ${i + 1}`,
                code: lines[i].trim(),
              });
            }
          }
        }
      }
    }
  }

  /**
   * Extract module name from file path
   */
  private extractModuleName(filePath: string): string {
    const modulesPath = path.join(process.cwd(), 'src', 'modules');
    const relativePath = path.relative(modulesPath, filePath);
    const parts = relativePath.split(path.sep);
    return parts[0] || 'unknown';
  }

  /**
   * Extract path from decorator
   */
  private extractDecoratorPath(decorator: any): string {
    const args = decorator.getArguments();
    
    if (args.length === 0) {
      return '';
    }

    const firstArg = args[0];
    const text = firstArg.getText();
    
    return text.replace(/['"]/g, '').replace(/`/g, '');
  }

  /**
   * Construct full route path
   */
  private constructFullPath(controllerPath: string, routePath: string): string {
    const parts: string[] = [];

    if (controllerPath) {
      parts.push(controllerPath.startsWith('/') ? controllerPath.substring(1) : controllerPath);
    }

    if (routePath) {
      parts.push(routePath.startsWith('/') ? routePath.substring(1) : routePath);
    }

    return '/' + parts.join('/');
  }

  /**
   * Generate markdown report
   */
  private generateReport(): void {
    const reportPath = path.join(process.cwd(), 'reports', 'throttling_status.md');

    const reportsDir = path.dirname(reportPath);
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }

    let content = '# ÿ™ŸÇÿ±Ÿäÿ± Rate Limiting & Throttling\n\n';
    content += `**ÿßŸÑÿ™ÿßÿ±ŸäÿÆ**: ${new Date().toLocaleDateString('ar-EG', { dateStyle: 'full' })}\n`;
    content += `**ÿßŸÑŸàŸÇÿ™**: ${new Date().toLocaleTimeString('ar-EG')}\n\n`;
    content += '---\n\n';

    // Package Status
    content += '## üì¶ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿ≤ŸÖ (Packages)\n\n';
    content += '| ÿßŸÑÿ≠ÿ≤ŸÖÿ© | ÿßŸÑÿ≠ÿßŸÑÿ© | ÿßŸÑÿ•ÿµÿØÿßÿ± |\n';
    content += '|--------|--------|----------|\n';
    
    for (const pkg of this.packagesInfo) {
      content += `| ${pkg.name} | ${pkg.present ? '‚úÖ ŸÖÿ´ÿ®ÿ™ÿ©' : '‚ùå ÿ∫Ÿäÿ± ŸÖÿ´ÿ®ÿ™ÿ©'} | ${pkg.version || '-'} |\n`;
    }
    content += '\n';

    // Current Implementation
    content += '## üõ°Ô∏è ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ≠ÿßŸÑŸä\n\n';
    
    const hasGlobalRateLimit = this.usage.some(u => u.type === 'middleware');
    const hasThrottleDecorators = this.usage.filter(u => u.type === 'decorator').length;
    
    if (hasGlobalRateLimit) {
      content += '### ‚úÖ Global Rate Limiting\n\n';
      content += 'ÿ™ŸÖ ÿ™ÿ∑ÿ®ŸäŸÇ rate limiting ÿπŸÑŸâ ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ŸÅŸä `main.ts` ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ `express-rate-limit`.\n\n';
      
      const middleware = this.usage.find(u => u.type === 'middleware');
      if (middleware) {
        content += '```typescript\n';
        content += middleware.code + '\n';
        content += '```\n\n';
      }
    } else {
      content += '### ‚ö†Ô∏è ŸÑÿß ŸäŸàÿ¨ÿØ Global Rate Limiting\n\n';
      content += 'ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ rate limiting ÿπŸÑŸâ ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ. ŸäŸèŸÜÿµÿ≠ ÿ®ÿ•ÿ∂ÿßŸÅÿ™Ÿá ŸÅŸä `main.ts`.\n\n';
    }

    if (hasThrottleDecorators > 0) {
      content += `### ‚úÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ @Throttle Decorator\n\n`;
      content += `ÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ${hasThrottleDecorators} ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÑŸÄ @Throttle decorator.\n\n`;
    } else {
      content += '### ‚ö†Ô∏è ŸÑÿß ŸäŸàÿ¨ÿØ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÑŸÄ @Throttle Decorator\n\n';
      content += 'ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÑŸÄ @Throttle ÿπŸÑŸâ ŸÖÿ≥ÿ™ŸàŸâ Controllers ÿ£Ÿà Routes.\n\n';
    }

    // Statistics
    content += '## üìä ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ Endpoints\n\n';
    
    const totalEndpoints = this.endpoints.length;
    const criticalEndpoints = this.endpoints.filter(e => e.isCritical).length;
    const protectedEndpoints = this.endpoints.filter(e => e.hasThrottle).length;
    const unprotectedCritical = this.endpoints.filter(e => e.isCritical && !e.hasThrottle).length;

    content += `- **ÿ•ÿ¨ŸÖÿßŸÑŸä Endpoints**: ${totalEndpoints}\n`;
    content += `- **Endpoints ÿ≠ÿ±ÿ¨ÿ©**: ${criticalEndpoints} (${this.percentage(criticalEndpoints, totalEndpoints)}%)\n`;
    content += `- **Endpoints ŸÖÿ≠ŸÖŸäÿ©**: ${protectedEndpoints} (${this.percentage(protectedEndpoints, totalEndpoints)}%)\n`;
    content += `- **Endpoints ÿ≠ÿ±ÿ¨ÿ© ÿ∫Ÿäÿ± ŸÖÿ≠ŸÖŸäÿ©**: ${unprotectedCritical} (${this.percentage(unprotectedCritical, criticalEndpoints)}%)\n\n`;

    // Progress bars
    content += this.generateProgressBar('Endpoints ŸÖÿ≠ŸÖŸäÿ©', this.percentage(protectedEndpoints, totalEndpoints));
    content += this.generateProgressBar('ÿ™ÿ∫ÿ∑Ÿäÿ© Endpoints ÿßŸÑÿ≠ÿ±ÿ¨ÿ©', this.percentage(criticalEndpoints - unprotectedCritical, criticalEndpoints));
    content += '\n';

    // Critical Endpoints Table
    content += '## ‚ö†Ô∏è Endpoints ÿ≠ÿ±ÿ¨ÿ© ÿ™ÿ≠ÿ™ÿßÿ¨ ÿ≠ŸÖÿßŸäÿ©\n\n';
    
    const unprotected = this.endpoints.filter(e => e.isCritical && !e.hasThrottle);
    
    if (unprotected.length === 0) {
      content += '_ÿ¨ŸÖŸäÿπ Endpoints ÿßŸÑÿ≠ÿ±ÿ¨ÿ© ŸÖÿ≠ŸÖŸäÿ©!_ üéâ\n\n';
    } else {
      content += `ÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ **${unprotected.length} endpoint ÿ≠ÿ±ÿ¨** ÿ®ÿØŸàŸÜ ÿ≠ŸÖÿßŸäÿ© throttling.\n\n`;
      content += '| ÿßŸÑŸÖÿ≥ÿßÿ± | HTTP | ÿßŸÑŸÖŸàÿØŸàŸÑ | ÿßŸÑÿ≥ÿ®ÿ® | ÿßŸÑŸÖŸÑŸÅ |\n';
      content += '|--------|------|---------|-------|-------|\n';

      for (const endpoint of unprotected) {
        content += `| \`${endpoint.path}\` | ${endpoint.httpMethod} | ${endpoint.module} | ${endpoint.criticalReason} | \`${endpoint.file}:${endpoint.line}\` |\n`;
      }
      content += '\n';
    }

    // Critical Endpoints by Category
    content += '## üìã ÿ™ÿµŸÜŸäŸÅ Endpoints ÿßŸÑÿ≠ÿ±ÿ¨ÿ©\n\n';
    
    const categories = new Map<string, EndpointInfo[]>();
    
    for (const endpoint of this.endpoints.filter(e => e.isCritical)) {
      const category = endpoint.criticalReason || 'Other';
      if (!categories.has(category)) {
        categories.set(category, []);
      }
      categories.get(category)!.push(endpoint);
    }

    for (const [category, endpoints] of Array.from(categories.entries()).sort((a, b) => b[1].length - a[1].length)) {
      const protectedCount = endpoints.filter(e => e.hasThrottle).length;
      const total = endpoints.length;
      
      content += `### ${category}\n\n`;
      content += `- **ÿßŸÑÿπÿØÿØ**: ${total}\n`;
      content += `- **ŸÖÿ≠ŸÖŸäÿ©**: ${protectedCount}/${total} (${this.percentage(protectedCount, total)}%)\n\n`;
      
      const needProtection = endpoints.filter(e => !e.hasThrottle);
      if (needProtection.length > 0) {
        content += '<details>\n<summary>ÿπÿ±ÿ∂ Endpoints ÿ∫Ÿäÿ± ÿßŸÑŸÖÿ≠ŸÖŸäÿ©</summary>\n\n';
        content += '| ÿßŸÑŸÖÿ≥ÿßÿ± | HTTP | ÿßŸÑŸÖŸàÿØŸàŸÑ |\n';
        content += '|--------|------|----------|\n';
        for (const ep of needProtection) {
          content += `| \`${ep.path}\` | ${ep.httpMethod} | ${ep.module} |\n`;
        }
        content += '\n</details>\n\n';
      }
    }

    // Recommendations
    content += '## üí° ÿßŸÑÿ™ŸàÿµŸäÿßÿ™\n\n';

    content += '### 1. ÿ•ÿ∂ÿßŸÅÿ© @nestjs/throttler\n\n';
    
    const hasThrottler = this.packagesInfo.find(p => p.name === '@nestjs/throttler')?.present;
    
    if (!hasThrottler) {
      content += '**ŸäŸèŸÜÿµÿ≠ ÿ®ÿ¥ÿØÿ©** ÿ®ÿ•ÿ∂ÿßŸÅÿ© `@nestjs/throttler` ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ™ÿ≠ŸÉŸÖ ÿ£ŸÅÿ∂ŸÑ ŸÅŸä rate limiting:\n\n';
      content += '```bash\n';
      content += 'npm install @nestjs/throttler\n';
      content += '```\n\n';
      content += 'ÿ´ŸÖ ÿ™ŸÅÿπŸäŸÑŸá ŸÅŸä `app.module.ts`:\n\n';
      content += '```typescript\n';
      content += 'import { ThrottlerModule, ThrottlerGuard } from \'@nestjs/throttler\';\n';
      content += 'import { APP_GUARD } from \'@nestjs/core\';\n\n';
      content += '@Module({\n';
      content += '  imports: [\n';
      content += '    ThrottlerModule.forRoot([{\n';
      content += '      ttl: 60000, // 60 seconds\n';
      content += '      limit: 10,  // 10 requests per ttl\n';
      content += '    }]),\n';
      content += '  ],\n';
      content += '  providers: [\n';
      content += '    {\n';
      content += '      provide: APP_GUARD,\n';
      content += '      useClass: ThrottlerGuard,\n';
      content += '    },\n';
      content += '  ],\n';
      content += '})\n';
      content += '```\n\n';
    }

    content += '### 2. ÿ≠ŸÖÿßŸäÿ© Endpoints ÿßŸÑÿ≠ÿ±ÿ¨ÿ©\n\n';
    
    if (unprotected.length > 0) {
      content += `Ÿäÿ¨ÿ® ÿ•ÿ∂ÿßŸÅÿ© throttling ŸÑŸÄ **${unprotected.length} endpoint**:\n\n`;
      
      // Group by module
      const byModule = new Map<string, EndpointInfo[]>();
      for (const ep of unprotected) {
        if (!byModule.has(ep.module)) {
          byModule.set(ep.module, []);
        }
        byModule.get(ep.module)!.push(ep);
      }

      for (const [module, endpoints] of Array.from(byModule.entries()).sort((a, b) => b[1].length - a[1].length).slice(0, 5)) {
        content += `#### ${module} (${endpoints.length} endpoints)\n\n`;
        content += '```typescript\n';
        content += 'import { Throttle } from \'@nestjs/throttler\';\n\n';
        content += `// ŸÅŸä ${endpoints[0].controller}\n`;
        content += '@Throttle({ default: { limit: 5, ttl: 60000 } }) // 5 requests per minute\n';
        content += `async ${endpoints[0].method}() {\n`;
        content += '  // ...\n';
        content += '}\n';
        content += '```\n\n';
      }
    }

    content += '### 3. ŸÖÿπÿØŸÑÿßÿ™ Throttling ÿßŸÑŸÖŸÇÿ™ÿ±ÿ≠ÿ©\n\n';
    content += '| ŸÜŸàÿπ Endpoint | ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ | ÿßŸÑŸÖÿØÿ© ÿßŸÑÿ≤ŸÖŸÜŸäÿ© |\n';
    content += '|--------------|-------------|---------------|\n';
    content += '| Authentication | 5 | 1 ÿØŸÇŸäŸÇÿ© |\n';
    content += '| Password Reset | 3 | 5 ÿØŸÇÿßÿ¶ŸÇ |\n';
    content += '| OTP/Verify | 3 | 1 ÿØŸÇŸäŸÇÿ© |\n';
    content += '| Payment | 10 | 1 ÿØŸÇŸäŸÇÿ© |\n';
    content += '| Search/Query | 20 | 1 ÿØŸÇŸäŸÇÿ© |\n';
    content += '| Upload | 5 | 5 ÿØŸÇÿßÿ¶ŸÇ |\n';
    content += '| Reports | 10 | 5 ÿØŸÇÿßÿ¶ŸÇ |\n';
    content += '| General API | 100 | 1 ÿØŸÇŸäŸÇÿ© |\n\n';

    content += '### 4. ÿ•ÿ∂ÿßŸÅÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ©\n\n';
    content += '- **Redis ŸÑŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™**: ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Redis ÿ®ÿØŸÑÿßŸã ŸÖŸÜ ÿßŸÑÿ∞ÿßŸÉÿ±ÿ© ŸÑŸÄ rate limiting ŸÅŸä ÿ®Ÿäÿ¶ÿ© multi-server\n';
    content += '- **Rate Limiting ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ**: ÿ™ÿ∑ÿ®ŸäŸÇ ÿ≠ÿØŸàÿØ ŸÖÿÆÿ™ŸÑŸÅÿ© ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ŸÜŸàÿπ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ (guest, authenticated, premium)\n';
    content += '- **IP Whitelisting**: ÿßÿ≥ÿ™ÿ´ŸÜÿßÿ° IPs ŸÖÿπŸäŸÜÿ© ŸÖŸÜ rate limiting (monitoring tools, trusted partners)\n';
    content += '- **Dynamic Rate Limiting**: ÿ™ÿπÿØŸäŸÑ ÿßŸÑÿ≠ÿØŸàÿØ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑÿ≠ŸÖŸÑ\n\n';

    content += '## üìù ÿÆÿ∑ÿ© ÿßŸÑÿπŸÖŸÑ\n\n';
    content += '- [ ] ÿ™ÿ´ÿ®Ÿäÿ™ `@nestjs/throttler` ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸÖÿ´ÿ®ÿ™ÿßŸã\n';
    content += '- [ ] ÿ™ŸÅÿπŸäŸÑ ThrottlerGuard ÿπŸÑŸâ ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ\n';
    content += `- [ ] ÿ•ÿ∂ÿßŸÅÿ© @Throttle ŸÑŸÄ ${unprotected.length} endpoint ÿ≠ÿ±ÿ¨\n`;
    content += '- [ ] ÿßÿÆÿ™ÿ®ÿßÿ± rate limiting ŸÅŸä ÿ®Ÿäÿ¶ÿ© ÿßŸÑÿ™ÿ∑ŸàŸäÿ±\n';
    content += '- [ ] ÿ•ÿπÿØÿßÿØ Redis ŸÑŸÑŸÄ production\n';
    content += '- [ ] ŸÖÿ±ÿßŸÇÿ®ÿ© rate limit metrics\n';
    content += '- [ ] ÿ™Ÿàÿ´ŸäŸÇ rate limits ŸÅŸä API documentation\n\n';

    content += '---\n\n';
    content += '_ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° Ÿáÿ∞ÿß ÿßŸÑÿ™ŸÇÿ±Ÿäÿ± ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ÿ®Ÿàÿßÿ≥ÿ∑ÿ© `tools/audit/throttling-check.ts`_\n';

    fs.writeFileSync(reportPath, content, 'utf-8');
    console.log(`üìä Report generated: ${reportPath}`);
  }

  /**
   * Calculate percentage
   */
  private percentage(value: number, total: number): number {
    if (total === 0) return 0;
    return Math.round((value / total) * 100);
  }

  /**
   * Generate progress bar
   */
  private generateProgressBar(label: string, percent: number): string {
    const barLength = 30;
    const filledLength = Math.round((percent / 100) * barLength);
    const emptyLength = barLength - filledLength;

    const filled = '‚ñà'.repeat(filledLength);
    const empty = '‚ñë'.repeat(emptyLength);

    return `**${label}**: [${filled}${empty}] ${percent}%\n`;
  }
}

// Run the audit
const auditor = new ThrottlingCheckAuditor();
auditor.audit().catch((error) => {
  console.error('‚ùå Error during audit:', error);
  process.exit(1);
});

